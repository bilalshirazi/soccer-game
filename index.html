<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Low Poly Soccer 3v3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #333; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #scoreboard { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.5); color: white; padding: 10px 20px; border-radius: 20px; 
            font-size: 24px; font-weight: bold; display: flex; gap: 20px; }
        #timer { position: absolute; top: 10px; right: 20px; color: white; font-size: 20px; font-weight: bold; }
        #message { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); 
            color: white; font-size: 40px; font-weight: bold; text-shadow: 2px 2px 4px #000; display: none; }
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); display: flex; 
            flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; z-index: 1000; }
        #start-screen h1 { font-size: 60px; color: white; text-shadow: 3px 3px 6px #000; margin: 0; }
        #start-screen .controls-info { color: white; font-size: 16px; margin: 20px; text-align: center; line-height: 1.8; }
        #start-btn, #play-again-btn { padding: 20px 40px; font-size: 24px; background: #4caf50; 
            color: white; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; pointer-events: auto; }
        #start-btn:hover, #play-again-btn:hover { background: #66bb6a; }
        #play-again-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, 50px); display: none; }
        #stamina-bar-container { position: absolute; bottom: 200px; left: 50%; transform: translateX(-50%); 
            width: 200px; height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; display: none; }
        #stamina-bar { width: 100%; height: 100%; background: linear-gradient(to right, #ffd700, #ffed4e); 
            border-radius: 10px; transition: width 0.1s; }
        #keyboard-hints { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); 
            color: white; font-size: 14px; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 10px; display: none; }
        #minimap { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 100px; 
            background: rgba(0,0,0,0.7); border: 2px solid white; border-radius: 5px; display: none; }

        /* Controls */
        .control-zone { position: absolute; bottom: 20px; height: 150px; width: 150px; pointer-events: auto; }
        #joystick-zone { left: 20px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #action-zone { right: 20px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); 
            display: flex; justify-content: center; align-items: center; flex-direction: column; }
        #action-btn { width: 80px; height: 80px; background: rgba(255, 200, 0, 0.5); border-radius: 50%; border: 2px solid white; }
        #action-btn.active { background: rgba(255, 200, 0, 0.8); transform: scale(0.95); }
        #action-label { color: white; font-weight: bold; font-size: 18px; margin-top: 10px; }
        #switch-zone { right: 20px; bottom: 190px; height: 120px; width: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; justify-content: center; align-items: center; flex-direction: column; }
        #switch-btn { width: 70px; height: 70px; background: rgba(100, 200, 255, 0.5); border-radius: 50%; border: 2px solid white; }
        #switch-btn.active { background: rgba(100, 200, 255, 0.8); transform: scale(0.95); }
        #switch-label { color: white; font-weight: bold; font-size: 14px; margin-top: 8px; }
        
        /* Joystick Knob */
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; 
            background: rgba(255,255,255,0.5); border-radius: 50%; transform: translate(-50%, -50%); }
    </style>
    
    <!-- Import Maps for CDN modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="game-container"></div>
    
    <div id="start-screen">
        <h1>LOW POLY 5v5 FUTSAL</h1>
        <div class="controls-info">
            <div style="margin-bottom: 20px;">
                <strong>MOVE</strong><br>
                Desktop: WASD / Arrow Keys<br>
                Mobile: Use left joystick
            </div>
            <div style="margin-bottom: 20px;">
                <strong>KICK / SPRINT</strong><br>
                Desktop: SPACE to Kick | SHIFT to Sprint<br>
                Mobile: Tap KICK button to Kick
            </div>
            <div style="margin-bottom: 20px;">
                <strong>SWITCH PLAYER</strong><br>
                Desktop: TAB or Q key<br>
                Mobile: Tap SWITCH button
            </div>
        </div>
        <button id="start-btn">START GAME</button>
    </div>
    
    <div id="ui-layer">
        <div id="scoreboard">
            <span style="color:#4488ff">BLUE <span id="score-blue">0</span></span>
            <span>-</span>
            <span style="color:#ff4444">RED <span id="score-red">0</span></span>
        </div>
        <div id="timer">02:00</div>
        <div id="message">GOAL!</div>
        <button id="play-again-btn">PLAY AGAIN</button>
        
        <div id="stamina-bar-container">
            <div id="stamina-bar"></div>
        </div>
        
        <div id="keyboard-hints">WASD: Move | SPACE: Kick | SHIFT: Sprint | TAB: Switch</div>
        
        <canvas id="minimap"></canvas>
        
        <div id="joystick-zone" class="control-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="action-zone" class="control-zone">
            <div id="action-btn"></div>
            <div id="action-label">KICK</div>
        </div>
        <div id="switch-zone" class="control-zone">
            <div id="switch-btn"></div>
            <div id="switch-label">SWITCH</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- CONFIGURATION ---
        const CONFIG = {
            fieldLength: 60, // X-axis (Futsal-like 60 units)
            fieldWidth: 40, // Z-axis (Futsal-like 40 units)
            playerSpeed: 120, // MASSIVELY INCREASED (was 45)
            aiSpeed: 100, // INCREASED (was 15)
            ballFriction: 0.1, // Reduced for faster rolling
            playerFriction: 0.5, // Reduced for snappier movement
            matchTime: 120,
            halftimeAt: 60,
            kickCooldown: 300, // Faster kicking
            sprintMultiplier: 1.6,
            maxStamina: 100,
            staminaDrainRate: 25,
            staminaRegenRate: 35, // Faster recovery
            kickPower: 35, // Stronger kick
            aiKickPower: 25,
            playerDamping: 0.95, // For snappy stops
            shadowMinScale: 0.3,
            shadowScaleFactor: 0.15,
            shadowMinOpacity: 0.2,
            shadowBaseOpacity: 0.5,
            shadowOpacityFactor: 0.1,
            shadowHeightOffset: 0.5,
            colors: {
                grassLight: 0x4caf50,
                grassDark: 0x3d9142,
                line: 0xffffff,
                blue: 0x4488ff,
                red: 0xff4444,
                ball: 0xffffff,
                skin: 0xffdbac
            }
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer, world;
        let clock, deltaTime, lastTime = 0;
        let players = [], ball, ballShadow;
        let input = { x: 0, y: 0, action: false, sprint: false, switchPlayer: false };
        let keys = {};
        let gameState = { 
            active: false, 
            scoreBlue: 0, 
            scoreRed: 0, 
            time: CONFIG.matchTime,
            halftimeTriggered: false,
            started: false
        };
        let controlledPlayerIndex = 0;
        let audioContext, sounds = {};
        let particles = [];
        let playerIdCounter = 0;
        let gameTimerInterval = null;

        // --- PHYSICS MATERIALS ---
        let groundMat, playerMat, ballMat;

        // --- INITIALIZATION ---
        function init() {
            // Three.js Setup
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 150);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 25);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting - Hemisphere + Directional
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3d5a3d, 0.6);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -40;
            dirLight.shadow.camera.right = 40;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            scene.add(dirLight);

            // Cannon.js Setup
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            
            groundMat = new CANNON.Material();
            playerMat = new CANNON.Material();
            ballMat = new CANNON.Material();

            const playerGroundContact = new CANNON.ContactMaterial(playerMat, groundMat, { 
                friction: 0.8, restitution: 0.0 
            });
            const ballGroundContact = new CANNON.ContactMaterial(ballMat, groundMat, { 
                friction: CONFIG.ballFriction, restitution: 0.3 
            });
            const ballPlayerContact = new CANNON.ContactMaterial(ballMat, playerMat, { 
                friction: 0.5, restitution: 0.4 
            });
            
            world.addContactMaterial(playerGroundContact);
            world.addContactMaterial(ballGroundContact);
            world.addContactMaterial(ballPlayerContact);

            createField();
            createBall();
            createTeam('blue', -1);
            createTeam('red', 1);
            
            setupInputs();
            setupAudio();
            
            // Set up controls based on device
            const isTouch = isTouchDevice();
            document.getElementById('keyboard-hints').style.display = isTouch ? 'none' : 'block';
            document.getElementById('joystick-zone').style.display = isTouch ? 'block' : 'none';
            document.getElementById('action-zone').style.display = isTouch ? 'block' : 'none';
            document.getElementById('switch-zone').style.display = isTouch ? 'block' : 'none';
            
            clock = new THREE.Clock();
            
            // Start button
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('play-again-btn').addEventListener('click', resetGame);
            
            // Start render loop (but game paused until start)
            animate();
        }

        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState.started = true;
            gameState.active = true;
            playSound('whistle');
            
            // Start timer (clear any existing)
            if(gameTimerInterval) clearInterval(gameTimerInterval);
            
            gameTimerInterval = setInterval(() => {
                if(gameState.active && gameState.time > 0) {
                    gameState.time--;
                    updateTimerUI();
                    
                    // Halftime
                    if(gameState.time === CONFIG.halftimeAt && !gameState.halftimeTriggered) {
                        triggerHalftime();
                    }
                    
                    if(gameState.time <= 0) endGame();
                }
            }, 1000);
        }

        function resetGame() {
            // Full reset
            if(gameTimerInterval) clearInterval(gameTimerInterval);
            
            gameState = { 
                active: true, 
                scoreBlue: 0, 
                scoreRed: 0, 
                time: CONFIG.matchTime,
                halftimeTriggered: false,
                started: true
            };
            
            updateScoreUI();
            updateTimerUI();
            resetPositions();
            
            document.getElementById('play-again-btn').style.display = 'none';
            document.getElementById('message').style.display = 'none';
            
            // Reset player stamina
            players.forEach(p => {
                if(p.isUser) p.stamina = CONFIG.maxStamina;
            });
            
            playSound('whistle');
            
            // Restart timer
            startGame();
        }


        function createField() {
            // Grass with stripes (East-West orientation)
            const stripeCount = 10;
            const stripeWidth = CONFIG.fieldLength / stripeCount;
            
            for(let i = 0; i < stripeCount; i++) {
                const color = i % 2 === 0 ? CONFIG.colors.grassLight : CONFIG.colors.grassDark;
                const geo = new THREE.PlaneGeometry(stripeWidth, CONFIG.fieldWidth);
                const mat = new THREE.MeshStandardMaterial({ color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.x = -CONFIG.fieldLength/2 + stripeWidth/2 + i * stripeWidth;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            // Field markings - Center line (runs North-South)
            const centerLineGeo = new THREE.PlaneGeometry(0.2, CONFIG.fieldWidth);
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const centerLine = new THREE.Mesh(centerLineGeo, lineMat);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.02;
            scene.add(centerLine);

            // Center circle
            const circleGeo = new THREE.RingGeometry(4.9, 5, 32);
            const circleMesh = new THREE.Mesh(circleGeo, lineMat);
            circleMesh.rotation.x = -Math.PI / 2;
            circleMesh.position.y = 0.02;
            scene.add(circleMesh);

            // Penalty areas (Futsal style arcs are usually 6m, using boxes here)
            // Depth: 10m (scaled), Width: 24m (scaled)
            createPenaltyArea(-CONFIG.fieldLength/2, 10, 24);
            createPenaltyArea(CONFIG.fieldLength/2, 10, 24);
            
            // Goal areas
            // Depth: 5m (scaled), Width: 12m (scaled)
            createGoalArea(-CONFIG.fieldLength/2, 5, 12);
            createGoalArea(CONFIG.fieldLength/2, 5, 12);
            
            // Penalty spots - 6m and 10m in Futsal, using 10m here
            createPenaltySpot(-CONFIG.fieldLength/2 + 10);
            createPenaltySpot(CONFIG.fieldLength/2 - 10);
            
            // Penalty arcs - centered on penalty spot
            createPenaltyArc(-CONFIG.fieldLength/2 + 10);
            createPenaltyArc(CONFIG.fieldLength/2 - 10);

            // Corner arcs
            createCornerArc(-CONFIG.fieldLength/2, -CONFIG.fieldWidth/2);
            createCornerArc(-CONFIG.fieldLength/2, CONFIG.fieldWidth/2);
            createCornerArc(CONFIG.fieldLength/2, -CONFIG.fieldWidth/2);
            createCornerArc(CONFIG.fieldLength/2, CONFIG.fieldWidth/2);

            // Boundary lines
            createBoundaryLine(CONFIG.fieldLength + 0.5, 0.2, 0, -CONFIG.fieldWidth/2);
            createBoundaryLine(CONFIG.fieldLength + 0.5, 0.2, 0, CONFIG.fieldWidth/2);
            createBoundaryLine(0.2, CONFIG.fieldWidth + 0.5, -CONFIG.fieldLength/2, 0);
            createBoundaryLine(0.2, CONFIG.fieldWidth + 0.5, CONFIG.fieldLength/2, 0);

            // Goals (Left and Right)
            createGoal(-CONFIG.fieldLength/2 - 2, 'blue');
            createGoal(CONFIG.fieldLength/2 + 2, 'red');

            // Invisible boundary walls
            createBoundaryWalls();

            // Physics Ground
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(CONFIG.fieldLength/2, 0.1, CONFIG.fieldWidth/2)),
                material: groundMat
            });
            groundBody.position.set(0, -0.1, 0);
            world.addBody(groundBody);
        }

        function createPenaltyArea(goalLineX, depth, width) {
            // Creates a penalty box extending from goal line toward midfield
            // goalLineX: X position of goal line (Â±fieldLength/2)
            // depth: how far the box extends toward midfield (X-direction)
            // width: width of the box across field (Z-direction)
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const direction = goalLineX < 0 ? 1 : -1; // Left goal extends right, right goal extends left
            
            // Line parallel to goal (farthest from goal)
            const farLineGeo = new THREE.PlaneGeometry(0.2, width);
            const farLine = new THREE.Mesh(farLineGeo, lineMat);
            farLine.rotation.x = -Math.PI / 2;
            farLine.position.set(goalLineX + direction * depth, 0.02, 0);
            scene.add(farLine);
            
            // Top line (perpendicular to goal)
            const topLineGeo = new THREE.PlaneGeometry(depth, 0.2);
            const topLine = new THREE.Mesh(topLineGeo, lineMat);
            topLine.rotation.x = -Math.PI / 2;
            topLine.position.set(goalLineX + direction * depth/2, 0.02, width/2);
            scene.add(topLine);
            
            // Bottom line (perpendicular to goal)
            const bottomLine = topLine.clone();
            bottomLine.position.z = -width/2;
            scene.add(bottomLine);
        }

        function createGoalArea(goalLineX, depth, width) {
            // Creates a goal box (6-yard box) extending from goal line
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const direction = goalLineX < 0 ? 1 : -1;
            
            // Line parallel to goal (farthest from goal)
            const farLineGeo = new THREE.PlaneGeometry(0.2, width);
            const farLine = new THREE.Mesh(farLineGeo, lineMat);
            farLine.rotation.x = -Math.PI / 2;
            farLine.position.set(goalLineX + direction * depth, 0.02, 0);
            scene.add(farLine);
            
            // Top line (perpendicular to goal)
            const topLineGeo = new THREE.PlaneGeometry(depth, 0.2);
            const topLine = new THREE.Mesh(topLineGeo, lineMat);
            topLine.rotation.x = -Math.PI / 2;
            topLine.position.set(goalLineX + direction * depth/2, 0.02, width/2);
            scene.add(topLine);
            
            // Bottom line (perpendicular to goal)
            const bottomLine = topLine.clone();
            bottomLine.position.z = -width/2;
            scene.add(bottomLine);
        }

        function createPenaltySpot(x) {
            const spotGeo = new THREE.CircleGeometry(0.3, 16);
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const spot = new THREE.Mesh(spotGeo, lineMat);
            spot.rotation.x = -Math.PI / 2;
            spot.position.set(x, 0.02, 0);
            scene.add(spot);
        }

        function createPenaltyArc(x) {
            const arcGeo = new THREE.RingGeometry(9.1, 9.3, 32, 1, 0, Math.PI);
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const arc = new THREE.Mesh(arcGeo, lineMat);
            arc.rotation.x = -Math.PI / 2;
            arc.rotation.z = x < 0 ? -Math.PI/2 : Math.PI/2;
            arc.position.set(x, 0.02, 0);
            scene.add(arc);
        }

        function createCornerArc(x, z) {
            const arcGeo = new THREE.RingGeometry(0.9, 1, 16, 1, 0, Math.PI/2);
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const arc = new THREE.Mesh(arcGeo, lineMat);
            arc.rotation.x = -Math.PI / 2;
            arc.rotation.z = Math.atan2(z, x);
            arc.position.set(x, 0.02, z);
            scene.add(arc);
        }

        function createBoundaryLine(width, length, x, z) {
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            const geo = new THREE.PlaneGeometry(width, length);
            const line = new THREE.Mesh(geo, lineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.set(x, 0.02, z);
            scene.add(line);
        }

        function createGoal(x, team) {
            const postRadius = 0.15;
            const postHeight = 3;
            const goalWidth = 10;
            
            const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const postGeo = new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 8);
            
            // Left post
            const leftPost = new THREE.Mesh(postGeo, postMat);
            leftPost.position.set(x, postHeight/2, -goalWidth/2);
            leftPost.castShadow = true;
            scene.add(leftPost);
            
            // Right post
            const rightPost = new THREE.Mesh(postGeo, postMat);
            rightPost.position.set(x, postHeight/2, goalWidth/2);
            rightPost.castShadow = true;
            scene.add(rightPost);
            
            // Crossbar
            const crossbarGeo = new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 8);
            const crossbar = new THREE.Mesh(crossbarGeo, postMat);
            crossbar.rotation.x = Math.PI / 2;
            crossbar.position.set(x, postHeight, 0);
            crossbar.castShadow = true;
            scene.add(crossbar);
            
            // Net (semi-transparent mesh)
            const netGeo = new THREE.PlaneGeometry(goalWidth, postHeight);
            const netMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const net = new THREE.Mesh(netGeo, netMat);
            net.position.set(x, postHeight/2, 0);
            net.rotation.y = x < 0 ? Math.PI/2 : -Math.PI/2;
            scene.add(net);
            
            // Goal trigger for scoring
            const side = x < 0 ? -1 : 1;
            const triggerBody = new CANNON.Body({ 
                mass: 0, 
                isTrigger: true,
                shape: new CANNON.Box(new CANNON.Vec3(2, 2, goalWidth/2))
            });
            triggerBody.position.set(x + side * 1, 2, 0);
            triggerBody.team = team;
            world.addBody(triggerBody);
            
            triggerBody.addEventListener('collide', (e) => {
                if(e.body === ball.body) {
                    scoreGoal(team);
                }
            });
        }

        function createBoundaryWalls() {
            const wallHeight = 5;
            const wallThickness = 1;
            
            const goalWidth = 10; // Goal width (matches createGoal function)
            
            // Left side walls (X = -fieldLength/2, two segments with gap for goal)
            // Top segment: from z = goalWidth/2 (5) to z = fieldWidth/2 (15)
            const wallSegmentHalfLength = (CONFIG.fieldWidth/2 - goalWidth/2) / 2; // Half-length of segment
            const leftTopWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, wallSegmentHalfLength))
            });
            leftTopWall.position.set(-CONFIG.fieldLength/2 - wallThickness, wallHeight, goalWidth/2 + wallSegmentHalfLength);
            world.addBody(leftTopWall);
            
            // Bottom segment: from z = -fieldWidth/2 (-15) to z = -goalWidth/2 (-5)
            const leftBottomWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, wallSegmentHalfLength))
            });
            leftBottomWall.position.set(-CONFIG.fieldLength/2 - wallThickness, wallHeight, -goalWidth/2 - wallSegmentHalfLength);
            world.addBody(leftBottomWall);
            
            // Right side walls (X = fieldLength/2, two segments with gap for goal)
            // Top segment: from z = goalWidth/2 (5) to z = fieldWidth/2 (15)
            const rightTopWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, wallSegmentHalfLength))
            });
            rightTopWall.position.set(CONFIG.fieldLength/2 + wallThickness, wallHeight, goalWidth/2 + wallSegmentHalfLength);
            world.addBody(rightTopWall);
            
            // Bottom segment: from z = -fieldWidth/2 (-15) to z = -goalWidth/2 (-5)
            const rightBottomWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, wallSegmentHalfLength))
            });
            rightBottomWall.position.set(CONFIG.fieldLength/2 + wallThickness, wallHeight, -goalWidth/2 - wallSegmentHalfLength);
            world.addBody(rightBottomWall);
            
            // Back walls behind each goal to prevent ball from escaping through goals
            const leftGoalBackWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, goalWidth/2))
            });
            leftGoalBackWall.position.set(-CONFIG.fieldLength/2 - 4, wallHeight, 0);
            world.addBody(leftGoalBackWall);
            
            const rightGoalBackWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, goalWidth/2))
            });
            rightGoalBackWall.position.set(CONFIG.fieldLength/2 + 4, wallHeight, 0);
            world.addBody(rightGoalBackWall);
            
            // Front and Back walls (along X-axis, now full length since goals are on sides)
            const backWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(CONFIG.fieldLength/2 + 5, wallHeight, wallThickness))
            });
            backWall.position.set(0, wallHeight, -CONFIG.fieldWidth/2 - wallThickness);
            world.addBody(backWall);
            
            const frontWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(CONFIG.fieldLength/2 + 5, wallHeight, wallThickness))
            });
            frontWall.position.set(0, wallHeight, CONFIG.fieldWidth/2 + wallThickness);
            world.addBody(frontWall);
        }


        function createTeam(teamColor, side) {
            const color = teamColor === 'blue' ? CONFIG.colors.blue : CONFIG.colors.red;
            const startX = side === -1 ? -CONFIG.fieldLength/4 : CONFIG.fieldLength/4;
            
            // 5-a-side team
            for(let i=0; i<5; i++) {
                const zStart = (i - 2) * 8; // Spread out 5 players
                const isUser = (teamColor === 'blue' && i === 2); // Middle player as starter
                createPlayer(startX, zStart, color, isUser, teamColor, i);
            }
        }

        function createPlayer(x, z, color, isUser, team, index) {
            const playerGroup = new THREE.Group();
            
            // Torso
            const torsoGeo = new THREE.BoxGeometry(0.8, 1.0, 0.5);
            const torsoMat = new THREE.MeshStandardMaterial({ color });
            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.castShadow = true;
            playerGroup.add(torso);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.35, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.8;
            head.castShadow = true;
            playerGroup.add(head);
            
            // Legs
            const legGeo = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.2, -0.7, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.2, -0.7, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);
            
            playerGroup.position.set(x, 1.1, z);
            scene.add(playerGroup);

            // User indicator
            if(isUser) {
                const arrowGeo = new THREE.ConeGeometry(0.4, 0.8, 8);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.y = 1.5;
                playerGroup.add(arrow);
                playerGroup.userData.arrow = arrow;
                controlledPlayerIndex = players.length;
            }

            // Physics
            const body = new CANNON.Body({
                mass: 5,
                shape: new CANNON.Sphere(0.8),
                material: playerMat
            });
            body.position.set(x, 1.1, z);
            body.linearDamping = 0.5;
            body.angularDamping = 0.99;
            body.angularFactor.set(0, 1, 0);
            world.addBody(body);

            const roles = ['defender', 'midfielder', 'attacker', 'midfielder', 'defender'];
            const player = { 
                mesh: playerGroup, 
                body, 
                team, 
                isUser, 
                startPos: {x, z}, 
                id: playerIdCounter++,
                role: roles[index % roles.length],
                lastKickTime: 0,
                stamina: isUser ? CONFIG.maxStamina : 0
            };
            players.push(player);
        }

        function createBall() {
            // Soccer ball with pattern
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // White base
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            
            // Black pentagons pattern
            ctx.fillStyle = '#000000';
            const positions = [
                [256, 100], [150, 200], [362, 200],
                [100, 350], [256, 400], [412, 350]
            ];
            positions.forEach(([x, y]) => {
                ctx.beginPath();
                for(let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI / 5) - Math.PI/2;
                    const px = x + Math.cos(angle) * 40;
                    const py = y + Math.sin(angle) * 40;
                    if(i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const geo = new THREE.SphereGeometry(0.5, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ map: texture });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.position.set(0, 2, 0);
            scene.add(mesh);

            const shape = new CANNON.Sphere(0.5);
            const body = new CANNON.Body({ mass: 1, material: ballMat });
            body.addShape(shape);
            body.position.set(0, 2, 0);
            body.linearDamping = 0.7;
            body.angularDamping = 0.8;
            world.addBody(body);

            // Ball shadow
            const shadowGeo = new THREE.CircleGeometry(0.6, 16);
            const shadowMat = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.4 
            });
            ballShadow = new THREE.Mesh(shadowGeo, shadowMat);
            ballShadow.rotation.x = -Math.PI / 2;
            ballShadow.position.y = 0.05;
            scene.add(ballShadow);

            ball = { mesh, body };
        }


        // --- INPUT HANDLING ---
        function setupInputs() {
            const joystickZone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            const actionZone = document.getElementById('action-zone');
            const actionBtn = document.getElementById('action-btn');

            let joystickCenter = { x: 0, y: 0 };
            let touchId = null;

            // Joystick
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                const rect = joystickZone.getBoundingClientRect();
                joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                updateJoystick(touch.clientX, touch.clientY);
            }, {passive: false});

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    }
                }
            }, {passive: false});

            const endJoystick = (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        touchId = null;
                        input.x = 0;
                        input.y = 0;
                        knob.style.transform = `translate(-50%, -50%)`;
                    }
                }
            };
            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            function updateJoystick(clientX, clientY) {
                const maxDist = 50;
                let dx = clientX - joystickCenter.x;
                let dy = clientY - joystickCenter.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }

                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                input.x = dx / maxDist;
                input.y = dy / maxDist;
            }

            // Action Button
            actionZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                input.action = true;
                actionBtn.classList.add('active');
            }, {passive: false});

            const endAction = (e) => {
                e.preventDefault();
                input.action = false;
                actionBtn.classList.remove('active');
            };
            actionZone.addEventListener('touchend', endAction);
            actionZone.addEventListener('touchcancel', endAction);

            // Switch Button
            const switchZone = document.getElementById('switch-zone');
            const switchBtn = document.getElementById('switch-btn');
            
            switchZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                switchBtn.classList.add('active');
                switchToNearestPlayer();
            }, {passive: false});

            const endSwitch = (e) => {
                e.preventDefault();
                switchBtn.classList.remove('active');
            };
            switchZone.addEventListener('touchend', endSwitch);
            switchZone.addEventListener('touchcancel', endSwitch);
            
            // Keyboard support - WASD + Arrow keys
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                // Also store arrow keys in lowercase for consistency
                if(e.key.startsWith('Arrow')) {
                    keys[e.key.toLowerCase().replace('arrow', '')] = true;
                }
                
                // WASD
                if(key === 'w' || e.key === 'ArrowUp') input.y = -1;
                if(key === 's' || e.key === 'ArrowDown') input.y = 1;
                if(key === 'a' || e.key === 'ArrowLeft') input.x = -1;
                if(key === 'd' || e.key === 'ArrowRight') input.x = 1;
                
                // Space for kick
                if(e.key === ' ') {
                    e.preventDefault();
                    input.action = true;
                }
                
                // Shift for sprint
                if(e.key === 'Shift') input.sprint = true;
                
                // Tab or Q for player switching
                if(e.key === 'Tab' || key === 'q') {
                    e.preventDefault();
                    switchToNearestPlayer();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
                
                // Also clear arrow keys stored in lowercase
                if(e.key.startsWith('Arrow')) {
                    keys[e.key.toLowerCase().replace('arrow', '')] = false;
                }
                
                if(key === 'w' || key === 's' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    // Recalculate y based on remaining keys
                    if(keys['w'] || keys['up']) input.y = -1;
                    else if(keys['s'] || keys['down']) input.y = 1;
                    else input.y = 0;
                }
                
                if(key === 'a' || key === 'd' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    // Recalculate x based on remaining keys
                    if(keys['a'] || keys['left']) input.x = -1;
                    else if(keys['d'] || keys['right']) input.x = 1;
                    else input.x = 0;
                }
                
                if(e.key === ' ') input.action = false;
                if(e.key === 'Shift') input.sprint = false;
            });
        }

        function switchToNearestPlayer() {
            if(!gameState.active) return;
            
            const currentPlayer = players[controlledPlayerIndex];
            const ballPos = ball.body.position;
            
            let nearestDist = Infinity;
            let nearestIndex = controlledPlayerIndex;
            
            players.forEach((p, i) => {
                if(p.team === 'blue' && i !== controlledPlayerIndex) {
                    const dist = p.body.position.distanceTo(ballPos);
                    if(dist < nearestDist) {
                        nearestDist = dist;
                        nearestIndex = i;
                    }
                }
            });
            
            if(nearestIndex !== controlledPlayerIndex) {
                // Remove arrow from current
                if(currentPlayer.mesh.userData.arrow) {
                    currentPlayer.mesh.remove(currentPlayer.mesh.userData.arrow);
                }
                currentPlayer.isUser = false;
                
                // Add arrow to new
                const newPlayer = players[nearestIndex];
                const arrowGeo = new THREE.ConeGeometry(0.4, 0.8, 4);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.y = 2.5;
                newPlayer.mesh.add(arrow);
                newPlayer.mesh.userData.arrow = arrow;
                newPlayer.isUser = true;
                newPlayer.stamina = currentPlayer.stamina;
                
                controlledPlayerIndex = nearestIndex;
            }
        }

        function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Simple beep sounds using Web Audio API
                sounds.kick = () => playTone(200, 0.1, 0.3);
                sounds.goal = () => playTone(440, 0.5, 0.5);
                sounds.whistle = () => playTone(800, 0.3, 0.4);
            } catch(e) {
                console.log('Audio not available');
            }
        }

        function playTone(freq, duration, volume) {
            if(!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = freq;
            gain.gain.value = volume;
            
            osc.start();
            setTimeout(() => osc.stop(), duration * 1000);
        }

        function playSound(name) {
            if(sounds[name]) sounds[name]();
        }


        // --- GAME LOGIC ---
        function updatePhysics() {
            const currentTime = performance.now() / 1000;
            deltaTime = Math.min(currentTime - lastTime, 0.1);
            lastTime = currentTime;
            
            // Fixed timestep
            world.step(1/60, deltaTime, 3);

            // Update ball
            ball.mesh.position.copy(ball.body.position);
            ball.mesh.quaternion.copy(ball.body.quaternion);
            
            // Update ball shadow
            ballShadow.position.x = ball.body.position.x;
            ballShadow.position.z = ball.body.position.z;
            const ballHeight = ball.body.position.y - CONFIG.shadowHeightOffset;
            const shadowScale = Math.max(CONFIG.shadowMinScale, 1 - ballHeight * CONFIG.shadowScaleFactor);
            ballShadow.scale.set(shadowScale, shadowScale, 1);
            ballShadow.material.opacity = Math.max(CONFIG.shadowMinOpacity, CONFIG.shadowBaseOpacity - ballHeight * CONFIG.shadowOpacityFactor);

            // Update particles
            updateParticles();

            // Update players
            players.forEach((p, index) => {
                // Synchronize physics to mesh
                p.mesh.position.set(p.body.position.x, p.body.position.y, p.body.position.z);
                
                // Rotation handling
                const vel = p.body.velocity;
                const speedSq = vel.x * vel.x + vel.z * vel.z;
                
                if (speedSq > 0.1) {
                    const targetAngle = Math.atan2(vel.x, vel.z);
                    const currentAngle = p.mesh.rotation.y;
                    let diff = targetAngle - currentAngle;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    p.mesh.rotation.y += diff * 0.15;
                }

                // Force uprightness in physics body
                p.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), p.mesh.rotation.y);

                if(p.isUser) {
                    updateUserPlayer(p);
                } else {
                    runAI(p);
                }
            });

            // Camera follow with smooth lerp
            const userPlayer = players.find(p => p.isUser);
            if(userPlayer) {
                const targetPos = new THREE.Vector3(
                    userPlayer.mesh.position.x * 0.3,
                    35,
                    userPlayer.mesh.position.z * 0.3 + 25
                );
                camera.position.lerp(targetPos, 0.05);
                
                const lookTarget = new THREE.Vector3(
                    userPlayer.mesh.position.x * 0.5,
                    0,
                    userPlayer.mesh.position.z * 0.5
                );
                const currentLookAt = new THREE.Vector3();
                camera.getWorldDirection(currentLookAt);
                currentLookAt.multiplyScalar(10).add(camera.position);
                currentLookAt.lerp(lookTarget, 0.05);
                camera.lookAt(currentLookAt);
            }
            
            // Update stamina bar
            if(userPlayer) {
                updateStaminaBar(userPlayer);
            }
        }

        function updateUserPlayer(p) {
            if(!gameState.active) return;
            
            // Sprint mechanics
            const isSprinting = input.sprint && p.stamina > 0 && (input.x !== 0 || input.y !== 0);
            const speedMultiplier = isSprinting ? CONFIG.sprintMultiplier : 1;
            
            // Update stamina
            if(isSprinting) {
                p.stamina = Math.max(0, p.stamina - CONFIG.staminaDrainRate * deltaTime);
            } else {
                p.stamina = Math.min(CONFIG.maxStamina, p.stamina + CONFIG.staminaRegenRate * deltaTime);
            }
            
            // Movement (East-West orientation: X is horizontal, Z is depth)
            const force = CONFIG.playerSpeed * speedMultiplier;
            p.body.applyForce(
                new CANNON.Vec3(input.x * force, 0, input.y * force), 
                p.body.position
            );
            
            // Kick action
            if(input.action) {
                const now = performance.now();
                if(now - p.lastKickTime > CONFIG.kickCooldown) {
                    const dist = p.body.position.distanceTo(ball.body.position);
                    if(dist < 2.5) {
                        kickBall(p);
                        p.lastKickTime = now;
                        input.action = false;
                    }
                }
            }
        }

        function kickBall(player) {
            const kickDir = new CANNON.Vec3();
            const vel = player.body.velocity;
            const velMag = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
            
            if(velMag > 0.5) {
                // Kick in movement direction
                kickDir.set(vel.x, 0, vel.z);
            } else {
                // Kick toward opponent goal
                const goalX = player.team === 'blue' ? CONFIG.fieldLength/2 : -CONFIG.fieldLength/2;
                kickDir.set(goalX - player.body.position.x, 0, -player.body.position.z * 0.3);
            }
            
            kickDir.normalize();
            const power = CONFIG.kickPower;
            ball.body.applyImpulse(
                new CANNON.Vec3(kickDir.x * power, 5, kickDir.z * power), 
                ball.body.position
            );
            
            playSound('kick');
            createKickParticles(ball.body.position);
        }

        function runAI(p) {
            if(!gameState.active) return;
            
            const ballPos = ball.body.position;
            const myPos = p.body.position;
            const distToBall = myPos.distanceTo(ballPos);
            const now = performance.now();
            
            let target = new CANNON.Vec3();
            let speed = CONFIG.aiSpeed;

            const goalX = p.team === 'blue' ? CONFIG.fieldLength/2 : -CONFIG.fieldLength/2;
            const myGoalX = p.team === 'blue' ? -CONFIG.fieldLength/2 : CONFIG.fieldLength/2;

            // Role-based AI
            if(p.role === 'attacker') {
                if(distToBall < 15) {
                    target.copy(ballPos);
                } else {
                    target.set(ballPos.x * 0.7 + goalX * 0.3, myPos.y, ballPos.z * 0.8);
                }
            } else if(p.role === 'midfielder') {
                if(distToBall < 12) {
                    target.copy(ballPos);
                } else {
                    target.set(ballPos.x * 0.5, myPos.y, ballPos.z * 0.7);
                }
            } else { // defender
                if(distToBall < 10) {
                    target.copy(ballPos);
                } else {
                    target.set(myGoalX * 0.3, myPos.y, ballPos.z * 0.6);
                }
            }

            // Move toward target
            const dir = new CANNON.Vec3();
            target.vsub(myPos, dir);
            dir.y = 0;
            dir.normalize();
            
            p.body.applyForce(new CANNON.Vec3(dir.x * speed, 0, dir.z * speed), p.body.position);

            // Kick logic when positioned to attack (ball is between AI and opponent goal)
            if(distToBall < 3.0 && now - p.lastKickTime > CONFIG.kickCooldown) {
                // Blue attacks right (goalX > myPos), Red attacks left (goalX < myPos)
                const shouldKick = (p.team === 'blue' && ballPos.x < myPos.x + 1) || 
                                   (p.team === 'red' && ballPos.x > myPos.x - 1);
                
                if(shouldKick) {
                    const kickDir = new CANNON.Vec3(goalX - ballPos.x, 2, -ballPos.z * 0.2);
                    kickDir.normalize();
                    const power = CONFIG.aiKickPower;
                    ball.body.applyImpulse(
                        new CANNON.Vec3(kickDir.x * power, kickDir.y * power, kickDir.z * power), 
                        ball.body.position
                    );
                    p.lastKickTime = now;
                    playSound('kick');
                    createKickParticles(ball.body.position);
                }
            }
        }

        function createKickParticles(position) {
            for(let i = 0; i < 10; i++) {
                const geo = new THREE.SphereGeometry(0.1, 4, 4);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true
                });
                const particle = new THREE.Mesh(geo, mat);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                particle.life = 0.5;
                particle.initialLife = 0.5;
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function createGoalParticles(position, color) {
            for(let i = 0; i < 50; i++) {
                const geo = new THREE.SphereGeometry(0.15, 4, 4);
                const mat = new THREE.MeshBasicMaterial({ 
                    color,
                    transparent: true
                });
                const particle = new THREE.Mesh(geo, mat);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 5
                );
                particle.life = 2;
                particle.initialLife = 2;
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function updateParticles() {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= deltaTime;
                
                if(p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                } else {
                    p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                    p.velocity.y -= 9.8 * deltaTime;
                    p.material.opacity = p.life / p.initialLife;
                }
            }
        }

        function updateStaminaBar(player) {
            const container = document.getElementById('stamina-bar-container');
            const bar = document.getElementById('stamina-bar');
            
            if(player.stamina < CONFIG.maxStamina || input.sprint) {
                container.style.display = 'block';
                bar.style.width = (player.stamina / CONFIG.maxStamina * 100) + '%';
            } else {
                container.style.display = 'none';
            }
        }


        function scoreGoal(goalOwner) {
            if(!gameState.active) return;
            gameState.active = false;
            
            // When ball enters a goal, the opposing team scores
            if(goalOwner === 'blue') gameState.scoreRed++;  // Ball in blue's goal â red scores
            else gameState.scoreBlue++;  // Ball in red's goal â blue scores
            
            updateScoreUI();
            playSound('goal');
            
            const scoringTeam = goalOwner === 'blue' ? 'red' : 'blue';
            const color = scoringTeam === 'blue' ? 0x4488ff : 0xff4444;
            createGoalParticles(ball.body.position, color);
            
            // Animated GOAL message
            const msg = document.getElementById('message');
            msg.innerHTML = "GOOOAL!";
            msg.style.display = 'block';
            msg.style.color = scoringTeam === 'blue' ? '#4488ff' : '#ff4444';
            msg.style.fontSize = '60px';
            
            // Animate message
            let scale = 1;
            const msgAnim = setInterval(() => {
                scale += 0.1;
                msg.style.transform = `translate(-50%, -50%) scale(${scale})`;
            }, 50);
            
            // Camera zoom to ball
            const targetPos = ball.body.position.clone();
            const zoomInterval = setInterval(() => {
                camera.position.lerp(new THREE.Vector3(targetPos.x, 15, targetPos.z + 10), 0.1);
                camera.lookAt(targetPos.x, 0, targetPos.z);
            }, 16);

            setTimeout(() => {
                clearInterval(msgAnim);
                clearInterval(zoomInterval);
                resetPositions();
                gameState.active = true;
                msg.style.display = 'none';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.fontSize = '40px';
            }, 3000);
        }

        function triggerHalftime() {
            gameState.halftimeTriggered = true;
            gameState.active = false;
            
            const msg = document.getElementById('message');
            msg.innerText = "HALFTIME - Teams Switch Sides!";
            msg.style.display = 'block';
            msg.style.color = '#ffffff';
            
            playSound('whistle');
            
            setTimeout(() => {
                // Switch team sides
                players.forEach(p => {
                    p.startPos.x = -p.startPos.x;
                    p.body.position.x = p.startPos.x;
                });
                
                resetPositions();
                gameState.active = true;
                msg.style.display = 'none';
            }, 3000);
        }

        function resetPositions() {
            ball.body.position.set(0, 5, 0);
            ball.body.velocity.set(0,0,0);
            ball.body.angularVelocity.set(0,0,0);

            players.forEach(p => {
                p.body.position.set(p.startPos.x, 2, p.startPos.z);
                p.body.velocity.set(0,0,0);
                p.body.angularVelocity.set(0,0,0);
            });
        }

        function endGame() {
            gameState.active = false;
            playSound('whistle');
            
            const msg = document.getElementById('message');
            const winner = gameState.scoreBlue > gameState.scoreRed ? "BLUE" : 
                          (gameState.scoreRed > gameState.scoreBlue ? "RED" : "DRAW");
            
            if(winner === "DRAW") {
                msg.innerText = "FULL TIME - IT'S A DRAW!";
                msg.style.color = '#ffffff';
            } else {
                msg.innerText = `FULL TIME - ${winner} WINS!`;
                msg.style.color = winner === "BLUE" ? '#4488ff' : '#ff4444';
                
                const winColor = winner === "BLUE" ? 0x4488ff : 0xff4444;
                createGoalParticles(new THREE.Vector3(0, 5, 0), winColor);
            }
            
            msg.style.display = 'block';
            document.getElementById('play-again-btn').style.display = 'block';
        }

        function updateScoreUI() {
            document.getElementById('score-blue').innerText = gameState.scoreBlue;
            document.getElementById('score-red').innerText = gameState.scoreRed;
        }

        function updateTimerUI() {
            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if(gameState.started) {
                updatePhysics();
            }
            
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        init();

    </script>
</body>
</html>

