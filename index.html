<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Low Poly Soccer 3v3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #333; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #scoreboard { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.5); color: white; padding: 10px 20px; border-radius: 20px; 
            font-size: 24px; font-weight: bold; display: flex; gap: 20px; }
        #timer { position: absolute; top: 10px; right: 20px; color: white; font-size: 20px; font-weight: bold; }
        #message { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); 
            color: white; font-size: 40px; font-weight: bold; text-shadow: 2px 2px 4px #000; display: none; }
        
        /* Gameplay Enhancement 5: Replay button */
        #replay-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(76, 175, 80, 0.9); color: white; font-size: 24px; font-weight: bold; 
            padding: 15px 40px; border: none; border-radius: 10px; cursor: pointer; pointer-events: auto; display: none; }
        #replay-btn:hover { background: rgba(76, 175, 80, 1); }
        
        /* UI Enhancement 10: Start screen */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            pointer-events: auto; z-index: 100; }
        #start-screen h1 { color: white; font-size: 48px; margin-bottom: 20px; text-shadow: 3px 3px 6px rgba(0,0,0,0.3); }
        #start-btn { background: rgba(76, 175, 80, 0.9); color: white; font-size: 28px; font-weight: bold; 
            padding: 20px 50px; border: none; border-radius: 15px; cursor: pointer; }
        #start-btn:hover { background: rgba(76, 175, 80, 1); transform: scale(1.05); }
        #start-screen.hidden { display: none; }
        
        /* UI Enhancement 12: Keyboard hints */
        #keyboard-hints { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); 
            color: white; font-size: 14px; text-align: center; background: rgba(0,0,0,0.5); 
            padding: 10px 15px; border-radius: 10px; display: none; }
        #keyboard-hints.show { display: block; }
        
        /* UI Enhancement 11: Kick button label */
        #action-btn-label { color: white; font-weight: bold; font-size: 16px; }

        /* Controls */
        .control-zone { position: absolute; bottom: 20px; height: 150px; width: 150px; pointer-events: auto; }
        #joystick-zone { left: 20px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #action-zone { right: 20px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; justify-content: center; align-items: center; }
        #action-btn { width: 80px; height: 80px; background: rgba(255, 200, 0, 0.5); border-radius: 50%; border: 2px solid white; }
        #action-btn.active { background: rgba(255, 200, 0, 0.8); transform: scale(0.95); }
        
        /* Joystick Knob */
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; 
            background: rgba(255,255,255,0.5); border-radius: 50%; transform: translate(-50%, -50%); }
    </style>
    
    <!-- Import Maps for CDN modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="game-container"></div>
    
    <!-- UI Enhancement 10: Start Screen -->
    <div id="start-screen">
        <h1>Low Poly Soccer 3v3</h1>
        <button id="start-btn">Start Game</button>
    </div>
    
    <div id="ui-layer">
        <div id="scoreboard">
            <span style="color:#4488ff">BLUE <span id="score-blue">0</span></span>
            <span>-</span>
            <span style="color:#ff4444">RED <span id="score-red">0</span></span>
        </div>
        <div id="timer">02:00</div>
        <div id="message">GOAL!</div>
        
        <!-- Gameplay Enhancement 5: Replay button -->
        <button id="replay-btn">Play Again</button>
        
        <!-- UI Enhancement 12: Keyboard hints -->
        <div id="keyboard-hints">
            <div>Movement: WASD or Arrow Keys</div>
            <div>Kick: Spacebar</div>
        </div>
        
        <div id="joystick-zone" class="control-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="action-zone" class="control-zone">
            <div id="action-btn">
                <!-- UI Enhancement 11: Kick button label -->
                <span id="action-btn-label">KICK</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- CONFIGURATION ---
        const CONFIG = {
            fieldWidth: 30,
            fieldLength: 50,
            playerSpeed: 10,
            ballFriction: 0.3,
            playerFriction: 0.9, // High friction for stopping
            matchTime: 120, // seconds
            colors: {
                grass: 0x4caf50,
                line: 0xffffff,
                blue: 0x4488ff,
                red: 0xff4444,
                ball: 0xffffff
            }
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer, world;
        let clock, deltaTime;
        let players = [], ball;
        let input = { x: 0, y: 0, action: false, actionCharge: 0 };
        let gameState = { active: false, scoreBlue: 0, scoreRed: 0, time: CONFIG.matchTime, started: false };
        let controlledPlayerIndex = 0; // User controls Blue 0 initially
        let timerInterval = null;

        // --- PHYSICS MATERIALS ---
        let groundMat, playerMat, ballMat;

        // --- INITIALIZATION ---
        function init() {
            // 1. Three.js Setup
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 50, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            // 2. Cannon.js Setup
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            
            // Materials
            groundMat = new CANNON.Material();
            playerMat = new CANNON.Material();
            ballMat = new CANNON.Material();

            const playerGroundContact = new CANNON.ContactMaterial(playerMat, groundMat, { friction: 0.8, restitution: 0.0 });
            const ballGroundContact = new CANNON.ContactMaterial(ballMat, groundMat, { friction: CONFIG.ballFriction, restitution: 0.5 });
            const ballPlayerContact = new CANNON.ContactMaterial(ballMat, playerMat, { friction: 0.5, restitution: 0.3 });
            
            world.addContactMaterial(playerGroundContact);
            world.addContactMaterial(ballGroundContact);
            world.addContactMaterial(ballPlayerContact);

            // 3. Create Field
            createField();

            // 4. Create Entities
            createBall();
            createTeam('blue', -1); // Left side
            createTeam('red', 1);   // Right side

            // 5. Input Listeners
            setupInputs();

            // 6. Start Loop
            clock = new THREE.Clock();
            animate();
            
            // UI Enhancement 10 & 12: Show keyboard hints on non-touch devices
            if(!('ontouchstart' in window)) {
                document.getElementById('keyboard-hints').classList.add('show');
            }
            
            // UI Enhancement 10: Setup start button
            document.getElementById('start-btn').addEventListener('click', startGame);
            
            // Gameplay Enhancement 5: Setup replay button
            document.getElementById('replay-btn').addEventListener('click', replayGame);
        }
        
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            gameState.active = true;
            gameState.started = true;
            
            // Start Timer
            timerInterval = setInterval(() => {
                if(gameState.active && gameState.time > 0) {
                    gameState.time--;
                    updateTimerUI();
                    if(gameState.time <= 0) endGame();
                }
            }, 1000);
        }
        
        function replayGame() {
            // Reset game state
            gameState.scoreBlue = 0;
            gameState.scoreRed = 0;
            gameState.time = CONFIG.matchTime;
            gameState.active = true;
            
            // Update UI
            updateScoreUI();
            updateTimerUI();
            document.getElementById('message').style.display = 'none';
            document.getElementById('replay-btn').style.display = 'none';
            
            // Reset positions
            resetPositions();
            
            // Restart timer
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(gameState.active && gameState.time > 0) {
                    gameState.time--;
                    updateTimerUI();
                    if(gameState.time <= 0) endGame();
                }
            }, 1000);
        }

        function createField() {
            // Visual Enhancement 9: Grass with stripes
            const stripeCount = 10;
            const stripeWidth = CONFIG.fieldLength / stripeCount;
            
            for(let i = 0; i < stripeCount; i++) {
                const geo = new THREE.PlaneGeometry(CONFIG.fieldWidth, stripeWidth);
                const shade = i % 2 === 0 ? 0x4caf50 : 0x45a049; // Alternate between two greens
                const mat = new THREE.MeshStandardMaterial({ color: shade });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.z = -CONFIG.fieldLength/2 + stripeWidth/2 + i * stripeWidth;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            // Visual Enhancement 7: Field markings
            const lineMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.line });
            
            // Border lines
            const topLine = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.fieldWidth + 1, 0.3), lineMat);
            topLine.position.set(0, 0.01, -CONFIG.fieldLength/2);
            topLine.rotation.x = -Math.PI / 2;
            scene.add(topLine);
            
            const bottomLine = topLine.clone();
            bottomLine.position.set(0, 0.01, CONFIG.fieldLength/2);
            scene.add(bottomLine);
            
            const leftLine = new THREE.Mesh(new THREE.PlaneGeometry(0.3, CONFIG.fieldLength), lineMat);
            leftLine.position.set(-CONFIG.fieldWidth/2, 0.01, 0);
            leftLine.rotation.x = -Math.PI / 2;
            scene.add(leftLine);
            
            const rightLine = leftLine.clone();
            rightLine.position.set(CONFIG.fieldWidth/2, 0.01, 0);
            scene.add(rightLine);
            
            // Center line
            const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.fieldWidth, 0.3), lineMat);
            centerLine.position.set(0, 0.01, 0);
            centerLine.rotation.x = -Math.PI / 2;
            scene.add(centerLine);
            
            // Center circle
            const circleGeo = new THREE.RingGeometry(4.9, 5.1, 32);
            const circleMesh = new THREE.Mesh(circleGeo, lineMat);
            circleMesh.position.set(0, 0.01, 0);
            circleMesh.rotation.x = -Math.PI / 2;
            scene.add(circleMesh);
            
            // Penalty areas
            const penaltyWidth = 16;
            const penaltyDepth = 8;
            
            // Blue penalty area (top)
            const bluePenaltyTop = new THREE.Mesh(new THREE.PlaneGeometry(penaltyWidth, 0.3), lineMat);
            bluePenaltyTop.position.set(0, 0.01, -CONFIG.fieldLength/2 + penaltyDepth);
            bluePenaltyTop.rotation.x = -Math.PI / 2;
            scene.add(bluePenaltyTop);
            
            const bluePenaltyLeft = new THREE.Mesh(new THREE.PlaneGeometry(0.3, penaltyDepth), lineMat);
            bluePenaltyLeft.position.set(-penaltyWidth/2, 0.01, -CONFIG.fieldLength/2 + penaltyDepth/2);
            bluePenaltyLeft.rotation.x = -Math.PI / 2;
            scene.add(bluePenaltyLeft);
            
            const bluePenaltyRight = bluePenaltyLeft.clone();
            bluePenaltyRight.position.set(penaltyWidth/2, 0.01, -CONFIG.fieldLength/2 + penaltyDepth/2);
            scene.add(bluePenaltyRight);
            
            // Red penalty area (bottom)
            const redPenaltyTop = new THREE.Mesh(new THREE.PlaneGeometry(penaltyWidth, 0.3), lineMat);
            redPenaltyTop.position.set(0, 0.01, CONFIG.fieldLength/2 - penaltyDepth);
            redPenaltyTop.rotation.x = -Math.PI / 2;
            scene.add(redPenaltyTop);
            
            const redPenaltyLeft = new THREE.Mesh(new THREE.PlaneGeometry(0.3, penaltyDepth), lineMat);
            redPenaltyLeft.position.set(-penaltyWidth/2, 0.01, CONFIG.fieldLength/2 - penaltyDepth/2);
            redPenaltyLeft.rotation.x = -Math.PI / 2;
            scene.add(redPenaltyLeft);
            
            const redPenaltyRight = redPenaltyLeft.clone();
            redPenaltyRight.position.set(penaltyWidth/2, 0.01, CONFIG.fieldLength/2 - penaltyDepth/2);
            scene.add(redPenaltyRight);

            // Visual Enhancement 8: Improved goal visuals (posts + crossbar)
            const postRadius = 0.2;
            const postHeight = 4;
            const goalWidth = 10;
            const postGeo = new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 8);
            const postMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            
            // Blue goal (top)
            const blueLeftPost = new THREE.Mesh(postGeo, postMat);
            blueLeftPost.position.set(-goalWidth/2, postHeight/2, -CONFIG.fieldLength/2 - 0.5);
            blueLeftPost.castShadow = true;
            scene.add(blueLeftPost);
            
            const blueRightPost = blueLeftPost.clone();
            blueRightPost.position.set(goalWidth/2, postHeight/2, -CONFIG.fieldLength/2 - 0.5);
            scene.add(blueRightPost);
            
            const blueCrossbar = new THREE.Mesh(
                new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 8),
                postMat
            );
            blueCrossbar.rotation.z = Math.PI / 2;
            blueCrossbar.position.set(0, postHeight, -CONFIG.fieldLength/2 - 0.5);
            blueCrossbar.castShadow = true;
            scene.add(blueCrossbar);
            
            // Blue goal net (semi-transparent)
            const netMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide 
            });
            const netGeo = new THREE.PlaneGeometry(goalWidth, postHeight);
            const blueNet = new THREE.Mesh(netGeo, netMat);
            blueNet.position.set(0, postHeight/2, -CONFIG.fieldLength/2 - 0.5);
            scene.add(blueNet);
            
            // Red goal (bottom)
            const redLeftPost = new THREE.Mesh(postGeo, postMat);
            redLeftPost.position.set(-goalWidth/2, postHeight/2, CONFIG.fieldLength/2 + 0.5);
            redLeftPost.castShadow = true;
            scene.add(redLeftPost);
            
            const redRightPost = redLeftPost.clone();
            redRightPost.position.set(goalWidth/2, postHeight/2, CONFIG.fieldLength/2 + 0.5);
            scene.add(redRightPost);
            
            const redCrossbar = new THREE.Mesh(
                new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 8),
                postMat
            );
            redCrossbar.rotation.z = Math.PI / 2;
            redCrossbar.position.set(0, postHeight, CONFIG.fieldLength/2 + 0.5);
            redCrossbar.castShadow = true;
            scene.add(redCrossbar);
            
            const redNet = new THREE.Mesh(netGeo, netMat);
            redNet.position.set(0, postHeight/2, CONFIG.fieldLength/2 + 0.5);
            scene.add(redNet);

            // Physics Ground
            const groundBody = new CANNON.Body({
                mass: 0, // Static
                shape: new CANNON.Box(new CANNON.Vec3(CONFIG.fieldWidth/2, 0.1, CONFIG.fieldLength/2)),
                material: groundMat
            });
            groundBody.position.set(0, -0.1, 0);
            world.addBody(groundBody);
            
            // Gameplay Enhancement 4: Add invisible walls around field perimeter
            const wallHeight = 5;
            const wallThickness = 0.5;
            
            // North wall (negative Z)
            const northWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(CONFIG.fieldWidth/2, wallHeight, wallThickness))
            });
            northWall.position.set(0, wallHeight, -CONFIG.fieldLength/2 - wallThickness);
            world.addBody(northWall);
            
            // South wall (positive Z)
            const southWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(CONFIG.fieldWidth/2, wallHeight, wallThickness))
            });
            southWall.position.set(0, wallHeight, CONFIG.fieldLength/2 + wallThickness);
            world.addBody(southWall);
            
            // West wall (negative X)
            const westWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, CONFIG.fieldLength/2))
            });
            westWall.position.set(-CONFIG.fieldWidth/2 - wallThickness, wallHeight, 0);
            world.addBody(westWall);
            
            // East wall (positive X)
            const eastWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight, CONFIG.fieldLength/2))
            });
            eastWall.position.set(CONFIG.fieldWidth/2 + wallThickness, wallHeight, 0);
            world.addBody(eastWall);
            
            // Goal Triggers (Simple boxes behind goals)
            createGoalTrigger(-CONFIG.fieldLength/2 - 2, 'blue');
            createGoalTrigger(CONFIG.fieldLength/2 + 2, 'red');
        }

        function createGoalTrigger(z, team) {
            const shape = new CANNON.Box(new CANNON.Vec3(5, 2, 1));
            const body = new CANNON.Body({ mass: 0, isTrigger: true });
            body.addShape(shape);
            body.position.set(0, 2, z);
            body.team = team;
            world.addBody(body);
            
            body.addEventListener('collide', (e) => {
                if(e.body === ball.body) {
                    scoreGoal(team);
                }
            });
        }

        function createTeam(teamColor, side) {
            const color = teamColor === 'blue' ? CONFIG.colors.blue : CONFIG.colors.red;
            const startX = side === -1 ? -10 : 10;
            
            // Create 3 players per team
            for(let i=0; i<3; i++) {
                const zStart = (i - 1) * 8; // Spread vertically
                const isUser = (teamColor === 'blue' && i === 0); // User controls Blue Captain
                createPlayer(startX, zStart, color, isUser, teamColor);
            }
        }

        function createPlayer(x, z, color, isUser, team) {
            // Visuals (Low Poly Cylinder)
            const geo = new THREE.CylinderGeometry(0.8, 0.8, 2, 8);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            scene.add(mesh);

            // Indicator for user
            if(isUser) {
                const arrowGeo = new THREE.ConeGeometry(0.5, 1, 4);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.y = 2;
                mesh.add(arrow);
                mesh.userData.isUser = true;
            }

            // Physics
            const shape = new CANNON.Sphere(0.8); // Sphere physics for smooth movement
            const body = new CANNON.Body({ mass: 5, material: playerMat });
            body.addShape(shape);
            body.position.set(x, 2, z);
            body.linearDamping = 0.9; // Momentum slide
            body.angularDamping = 1.0; // Prevent rolling
            world.addBody(body);

            // Bug Fix 1: Assign proper id to each player
            const playerId = players.length;
            players.push({ mesh, body, team, isUser, startPos: {x, z}, id: playerId });
        }

        function createBall() {
            const geo = new THREE.IcosahedronGeometry(0.6, 1);
            const mat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ball, flatShading: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Sphere(0.6);
            const body = new CANNON.Body({ mass: 1, material: ballMat });
            body.addShape(shape);
            body.position.set(0, 2, 0);
            body.linearDamping = 0.5;
            world.addBody(body);

            ball = { mesh, body };
        }

        // --- INPUT HANDLING ---
        function setupInputs() {
            const joystickZone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            const actionZone = document.getElementById('action-zone');
            const actionBtn = document.getElementById('action-btn');

            let joystickCenter = { x: 0, y: 0 };
            let touchId = null;

            // Joystick
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                const rect = joystickZone.getBoundingClientRect();
                joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                updateJoystick(touch.clientX, touch.clientY);
            }, {passive: false});

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    }
                }
            }, {passive: false});

            const endJoystick = (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        touchId = null;
                        input.x = 0;
                        input.y = 0;
                        knob.style.transform = `translate(-50%, -50%)`;
                    }
                }
            };
            joystickZone.addEventListener('touchend', endJoystick);
            joystickZone.addEventListener('touchcancel', endJoystick);

            function updateJoystick(clientX, clientY) {
                const maxDist = 50;
                let dx = clientX - joystickCenter.x;
                let dy = clientY - joystickCenter.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist > maxDist) {
                    const ratio = maxDist / dist;
                    dx *= ratio;
                    dy *= ratio;
                }

                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Normalize input -1 to 1
                input.x = dx / maxDist;
                input.y = dy / maxDist;
            }

            // Action Button
            actionZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                input.action = true;
                actionBtn.classList.add('active');
            }, {passive: false});

            const endAction = (e) => {
                e.preventDefault();
                input.action = false;
                actionBtn.classList.remove('active');
                input.actionCharge = 0; // Reset charge
            };
            actionZone.addEventListener('touchend', endAction);
            actionZone.addEventListener('touchcancel', endAction);
            
            // Keyboard fallback for testing on PC
            // Gameplay Enhancement 6: Add WASD support
            window.addEventListener('keydown', (e) => {
                if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') input.y = -1;
                if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') input.y = 1;
                if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.x = -1;
                if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.x = 1;
                if(e.key === ' ') input.action = true;
            });
            window.addEventListener('keyup', (e) => {
                if(['ArrowUp','ArrowDown','w','W','s','S'].includes(e.key)) input.y = 0;
                if(['ArrowLeft','ArrowRight','a','A','d','D'].includes(e.key)) input.x = 0;
                if(e.key === ' ') input.action = false;
            });
        }

        // --- GAME LOGIC ---
        function updatePhysics() {
            world.step(1/60);

            // Sync Ball
            ball.mesh.position.copy(ball.body.position);
            ball.mesh.quaternion.copy(ball.body.quaternion);

            // Sync Players & AI Logic
            players.forEach((p, index) => {
                p.mesh.position.copy(p.body.position);
                p.mesh.quaternion.copy(p.body.quaternion);

                // Keep players on field (simple constraint)
                if(p.body.position.y < 1) {
                    p.body.position.y = 1;
                    p.body.velocity.y = 0;
                }

                if(p.isUser) {
                    // User Control
                    const force = 15;
                    p.body.applyForce(new CANNON.Vec3(input.x * force, 0, input.y * force), p.body.position);
                    
                    // Action (Kick/Sprint)
                    if(input.action) {
                        // Check distance to ball
                        const dist = p.body.position.distanceTo(ball.body.position);
                        if(dist < 2.5) {
                            // Bug Fix 3: Kick in direction of movement or toward goal if stationary
                            const kickDir = new CANNON.Vec3();
                            const speed = p.body.velocity.length();
                            
                            if(speed > 0.5) {
                                // Kick in direction of movement
                                kickDir.copy(p.body.velocity);
                                kickDir.normalize();
                            } else {
                                // Kick toward opponent goal if stationary
                                const goalZ = p.team === 'blue' ? CONFIG.fieldLength/2 : -CONFIG.fieldLength/2;
                                kickDir.set(0, 0, goalZ - ball.body.position.z);
                                kickDir.normalize();
                            }
                            
                            const kickForce = 20;
                            ball.body.applyImpulse(new CANNON.Vec3(kickDir.x * kickForce, 2, kickDir.z * kickForce), ball.body.position);
                            input.action = false; // Consume input
                        }
                    }
                } else {
                    // AI Logic
                    runAI(p);
                }
            });

            // Camera Follow User
            const userPlayer = players.find(p => p.isUser);
            if(userPlayer) {
                const targetPos = userPlayer.mesh.position.clone();
                targetPos.y += 15;
                targetPos.z += 20;
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(userPlayer.mesh.position);
            }
        }

        function runAI(p) {
            const ballPos = ball.body.position;
            const myPos = p.body.position;
            const distToBall = myPos.distanceTo(ballPos);
            
            // Simple State Machine
            let target = new CANNON.Vec3();
            let speed = 8;

            // Determine Goal Direction based on team
            const goalZ = p.team === 'blue' ? CONFIG.fieldLength/2 : -CONFIG.fieldLength/2;

            if (distToBall < 10) {
                // Chase Ball
                target.copy(ballPos);
                // Add some offset so they don't all stack
                target.x += (p.id % 2 === 0 ? 2 : -2); 
            } else {
                // Return to formation relative to ball
                target.set(myPos.x, myPos.y, ballPos.z * 0.5 + p.startPos.z * 0.5);
            }

            // Move towards target
            const dir = new CANNON.Vec3();
            target.vsub(myPos, dir);
            dir.normalize();
            
            // Apply force
            p.body.applyForce(new CANNON.Vec3(dir.x * speed, 0, dir.z * speed), p.body.position);

            // Bug Fix 2: Both teams should kick the ball
            if(distToBall < 2.5) {
                 // Check if between ball and goal
                 if((p.team === 'blue' && ballPos.z < myPos.z) || (p.team === 'red' && ballPos.z > myPos.z)) {
                    const kickForce = 15;
                    const kickDir = new CANNON.Vec3(0, 2, (goalZ - ballPos.z)); 
                    kickDir.normalize();
                    ball.body.applyImpulse(new CANNON.Vec3(kickDir.x * kickForce, kickDir.y * kickForce, kickDir.z * kickForce), ball.body.position);
                 }
            }
        }

        function scoreGoal(team) {
            if(!gameState.active) return;
            gameState.active = false;
            
            if(team === 'blue') gameState.scoreBlue++;
            else gameState.scoreRed++;
            
            updateScoreUI();
            
            const msg = document.getElementById('message');
            msg.innerText = team === 'blue' ? "BLUE SCORES!" : "RED SCORES!";
            msg.style.display = 'block';
            msg.style.color = team === 'blue' ? '#4488ff' : '#ff4444';

            setTimeout(() => {
                resetPositions();
                gameState.active = true;
                msg.style.display = 'none';
            }, 2000);
        }

        function resetPositions() {
            ball.body.position.set(0, 5, 0);
            ball.body.velocity.set(0,0,0);
            ball.body.angularVelocity.set(0,0,0);

            players.forEach(p => {
                p.body.position.set(p.startPos.x, 2, p.startPos.z);
                p.body.velocity.set(0,0,0);
            });
        }

        function endGame() {
            gameState.active = false;
            const msg = document.getElementById('message');
            msg.innerText = gameState.scoreBlue > gameState.scoreRed ? "BLUE WINS!" : (gameState.scoreRed > gameState.scoreBlue ? "RED WINS!" : "DRAW!");
            msg.style.display = 'block';
            
            // Gameplay Enhancement 5: Show replay button
            document.getElementById('replay-btn').style.display = 'block';
        }

        function updateScoreUI() {
            document.getElementById('score-blue').innerText = gameState.scoreBlue;
            document.getElementById('score-red').innerText = gameState.scoreRed;
        }

        function updateTimerUI() {
            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        init();

    </script>
</body>
</html>

